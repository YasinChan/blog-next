import{_ as c,r as e,o as l,c as r,a,b as n,d as t,w as p,e as i}from"./app-1H-DQw8b.js";const u={},d=a("h1",{id:"slate-系列-在编辑器中输入-a-发生了什么",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#slate-系列-在编辑器中输入-a-发生了什么"},[a("span",null,"slate 系列 - 在编辑器中输入 A 发生了什么")])],-1),k=a("div",{class:"custom-container tip"},[a("p",{class:"custom-container-title"},"TIP"),a("p",null,"本文将结合文本输入，细究 slate 内部执行逻辑。")],-1),b={href:"https://github.com/ianstormtaylor/slate/blob/d2fc25c3c31453597f59cd2ac6ba087a1beb1fe3/packages/slate-react/src/components/editable.tsx#L274",target:"_blank",rel:"noopener noreferrer"},f={href:"http://Transforms.select",target:"_blank",rel:"noopener noreferrer"},m={href:"https://github.com/ianstormtaylor/slate/blob/d2fc25c3c31453597f59cd2ac6ba087a1beb1fe3/packages/slate/src/transforms/general.ts#L230",target:"_blank",rel:"noopener noreferrer"},h={href:"https://github.com/ianstormtaylor/slate/blob/d2fc25c3c31453597f59cd2ac6ba087a1beb1fe3/packages/slate/src/create-editor.ts#L81",target:"_blank",rel:"noopener noreferrer"},g={href:"https://github.com/ianstormtaylor/slate/blob/d2fc25c3c31453597f59cd2ac6ba087a1beb1fe3/packages/slate-react/src/components/editable.tsx#L326",target:"_blank",rel:"noopener noreferrer"},_={href:"https://github.com/ianstormtaylor/slate/blob/d2fc25c3c31453597f59cd2ac6ba087a1beb1fe3/packages/slate/src/transforms/general.ts#L45",target:"_blank",rel:"noopener noreferrer"},v={href:"https://github.com/ianstormtaylor/slate/blob/d2fc25c3c31453597f59cd2ac6ba087a1beb1fe3/packages/slate/src/create-editor.ts#L95",target:"_blank",rel:"noopener noreferrer"},x=i(`<li><p>这里会有一个问题，当调用某个复杂命令时，会在一个 task 中执行多次 apply，这意味着 onChange 会被调用多次，而 slate 这里用了一个巧妙的方式：将 onChange 放在 Promise 的回调中，在当前 task 完成后才会调用一次 onChange 方法。</p><div class="language-jsx line-numbers-mode" data-ext="jsx" data-title="jsx"><pre class="language-jsx"><code><span class="token comment">// https://github.com/ianstormtaylor/slate/blob/d2fc25c3c31453597f59cd2ac6ba087a1beb1fe3/packages/slate/src/create-editor.ts#L90</span>
<span class="token function-variable function">apply</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	<span class="token operator">...</span>
	<span class="token operator">...</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token constant">FLUSHING</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>editor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  <span class="token constant">FLUSHING</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>editor<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>

	  Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
	    <span class="token constant">FLUSHING</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>editor<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
	    editor<span class="token punctuation">.</span><span class="token function">onChange</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	    editor<span class="token punctuation">.</span>operations <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
	  <span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>这里涉及了执行栈和队列的知识，我们知道 js 是单线程的，异步任务会被先放置于队列中，当同步任务执行完后，会执行队列中的异步任务。</li><li>异步任务中会分宏任务（task）和微任务（microtask），浏览器在每个 task 之间会执行 DOM 重新渲染的逻辑，也就是 task → 渲染 → task 。</li><li>而微任务将会在第一个 task 之后和渲染之前执行</li><li>Promise.then 是微任务，所以 slate 这里多次执行的 apply ，会将其中的 Promise.then 放到队列中，当同步任务执行完，在 DOM 重新渲染之前执行其中的 onChange 事件。</li></ul></li>`,1),y={href:"https://github.com/ianstormtaylor/slate/blob/main/packages/slate-react/src/components/slate.tsx",target:"_blank",rel:"noopener noreferrer"},L={href:"https://github.com/ianstormtaylor/slate/blob/d2fc25c3c31453597f59cd2ac6ba087a1beb1fe3/packages/slate-react/src/components/slate.tsx#L29",target:"_blank",rel:"noopener noreferrer"},C={href:"https://github.com/ianstormtaylor/slate/blob/d2fc25c3c31453597f59cd2ac6ba087a1beb1fe3/packages/slate-react/src/components/slate.tsx#L99",target:"_blank",rel:"noopener noreferrer"};function T(N,E){const s=e("ExternalLinkIcon"),o=e("RouteLink");return l(),r("div",null,[d,k,a("ol",null,[a("li",null,[a("p",null,[n("光标先选中一个位置，触发 "),a("a",b,[n("selectionchange"),t(s)]),n(" 事件，在事件中，通过 js 原生 getSelection 方法，获取到当前光标坐标 selection，再通过 slate-react 的 ReactEditor.toSlateRange 方法，获取 slate range，再使用 "),a("a",f,[n("Transforms.select"),t(s)]),n(" 将该 range 设置到 editor.selection 上，这里将执行 apply 的 "),a("a",m,[n("set_selection"),t(s)]),n(" 操作（这个方法是在"),a("a",h,[n("这里"),t(s)]),n("被触发的）。")])]),a("li",null,[a("p",null,[n("输入 A 时，触发 slate-react 中的 "),a("a",g,[n("beforeinput"),t(s)]),n(" 事件，判断到 event.inputType 为 insertText 时，使用 Editor.insertText 方法插入文本")])]),a("li",null,[a("p",null,[n("在 Editor.insertText 中将执行 apply "),a("a",_,[n("insert_text"),t(s)]),n(" 操作")])]),a("li",null,[a("p",null,[n("以上的 apply 操作，都是对 Operation 的操作，当 Operation 处理完之后，会主动触发 "),a("a",v,[n("onChange"),t(s)]),n(" 事件，目的是 react 的重新渲染。")])]),x,a("li",null,[a("p",null,[n("onChange 会在 "),a("a",y,[n("react 组件"),t(s)]),n("中更改 "),a("a",L,[n("state 的 Hook"),t(s)]),n("，并且触发 "),a("a",C,[n("Context.Provider"),t(s)]),n(" 的值的改变，从而更新组件。")])])]),a("p",null,[n("上一篇 "),t(o,{to:"/post/html-different-space-slate.html"},{default:p(()=>[n("slate 系列 - 不同空格的处理")]),_:1})])])}const S=c(u,[["render",T],["__file","slate-after-entering-a.html.vue"]]),j=JSON.parse('{"path":"/post/slate-after-entering-a.html","title":"slate 系列 - 在编辑器中输入 A 发生了什么","lang":"zh-CN","frontmatter":{"date":"2022-05-12T00:00:00.000Z","tag":["slate","queue","execution-stack"],"sticky":true,"excerpt":"本文将结合文本输入，细究 slate 内部执行逻辑。"},"headers":[],"git":{"updatedTime":1711200423000,"contributors":[{"name":"YasinChan","email":"yasinchan2016@gmail.com","commits":1}]},"filePathRelative":"post/slate-after-entering-a.md"}');export{S as comp,j as data};
